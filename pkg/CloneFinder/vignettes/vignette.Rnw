\documentclass{article}
\usepackage{Sweave}
\usepackage{combinat}
\usepackage{quantmod}
\usepackage{gtools}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-.5in}
\setlength{\evensidemargin}{\oddsidemargin}
\newcommand{\code}[1]{\texttt{#1}}
\title{CloneFinder}
\author{Mark Zucker \and Kevin Coombes}
\date{November, 2018} 

\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle

\section{Introduction}
Tumors often consist of multiple distinct subpopulation or clones. One can determine the number of clones present in a tumor using either sequencing data or SNP array data. The cloneFinder package can be applied to either SNP array data or sequencing data, or both, from tumor cells from a cancer patient to determine the number of clones, the distribution of cells among clones, and the copy number variations (CNVs) and mutations occur in each clone. The presence of multiple detectable clones is called 'clonal heterogeneity' in the literature.

Clonal heterogeneity likely plays an important role in the clinical course of a cancer. It is possible, for example, that the tumor cells that will eventually become the refractory cancer after treatment are present as a minor subclone in the tumor early on.

\section{SNP Array Data}
To run CloneFinder we will need a starting set of 'psi' vectors as inputs ('psi' denotes the fraction of cells belonging to each clone). For each psi vector, the algorithm will compute the most probable copy number state for each clone at each segment. The maximum posterior probability is computed for each imput psi vector, and these probabilities are used to resample new potential psi vectors. The initial psi matrix we use can be generated using the 'xsimplex from the combinat package:
<<eval=TRUE, echo=TRUE>>=
library(combinat)
library(quantmod)
library(gtools)
library(CloneFinder)

simplex <- t(xsimplex(5, 20))
for(i in 1:nrow(simplex)){
  simplex[i,] <- sort(simplex[i,], decreasing=TRUE)
}
simplex <- unique(simplex)
psis <- unname(Reduce(rbind,lapply(1:nrow(simplex), function(i){simplex[i,]/20})))
@
For SNP array data, we also need, as input, a set of possible clonal segment copy number states (). If none exists the unction will automatically generate one.
<<eval=TRUE, echo=TRUE>>=
cnmodels <- expand.grid(rep(list(0:5),5))
include <- which(sapply(1:nrow(cnmodels),function(i){length(which(cnmodels[i,]>=1))==5 | length(which(cnmodels[i,]<=1))==5}))
cnmodels <- cnmodels[include,]
@

Now we will define algorithm parameters:
<<eval=TRUE, echo=TRUE>>=
pars <- list('sigma0'=5, 'theta'=.9, 'ktheta'=.3, 'mtheta'=.9, 'alpha'=.5, 'thresh'=.04, 'cutoff'=100, 'Q'=100, 'iters'=4)
@

First, let's illustrate the use of CloneFinder in analyzing SNP array data to identify the clones present. We will load in some simulated mutation data. We'll also load in the actual simulated tumor information so we can compare the truth with the results:
<<eval=TRUE, echo=TRUE>>=
path <- 'C:/Users/Mark/OneDrive - The Ohio State University/clonetools/docPath'
setwd(path)
simCN <- get(load('simCN.rda'))$tumor
simDatCN <- get(load('simDatCN.rda'))$dat
cnDat <- simDatCN$cn.data
head(simDatCN)
@
And the results:
<<eval=TRUE, echo=TRUE>>=
resCN <- findClones(cndata=cnDat, vardata=NULL, cnmodels=cnmodels, psis, pars=pars)
@

The results of the 'only CNV' analysis of this sample:
<<eval=TRUE, echo=TRUE>>=
resCN$psi
simCN$psi
@
So CloneFinder also accurately estimates the clonal fractions in this case as well. Let's look at the clonal copy number assignments as well:
<<eval=TRUE, echo=TRUE>>=
trueCN_Assignments <- t(sapply(1:nrow(resCN$filtered.data$cndata.filt),function(i){
  index <- which(rownames(simCN$clones[[1]]$cn)==rownames(resCN$filtered.data$cndata.filt)[i])
  sapply(1:length(simCN$clones),function(j){
    simCN$clones[[j]]$cn$A[index] + simCN$clones[[j]]$cn$B[index]
  })
}))

inferredCN_Assignments <- (resCN$A+resCN$B)[,1:length(simCN$clones)]
colnames(inferredCN_Assignments) <- colnames(trueCN_Assignments) <- c('clone1','clone2')

#Clonal copy numbers for each potentially 'deviant' segment, true and inferred:
trueCN_Assignments
inferredCN_Assignments
@


\section{Sequencing Data}
Now, let's illustrate the use of CloneFinder in analyzing mutation data (by which I mean variant data such as one would find in a .vcf file) to find clones. We will load in some simulated mutation data. We are interested here in the variants, not the CNVs, and therefore more specifically in somatic mutation data:

<<eval=TRUE, echo=TRUE>>=
simDatMut <- get(load('simDatMut.rda'))$dat
seqDat <- simDatMut$seq.data
somatic <- seqDat[seqDat$status=='somatic',]
@
The data looks like this:
<<eval=TRUE, echo=FALSE>>=
head(somatic)
@
Once again. we'll also load the original simulated tumor information, so we can compare the results of the analysis with the pre-determined truth.
<<eval=TRUE, echo=FALSE>>=
simMut <- get(load('simMut.rda'))$tumor
@

And run clonefinder:
<<eval=TRUE, echo=TRUE>>=
resMut <- findClones(cndata=NULL, vardata=somatic, cnmodels=cnmodels, psiset=psis, pars=pars)
@
The results show that CloneFinder reached a good approximation for 'psis', the clonal fractions:
<<eval=TRUE, echo=TRUE>>=
resMut$psi
simMut$psi
@
Let's also look at the mutation assignment compared to the truth:
<<eval=TRUE, echo=TRUE>>=
trueMutAssignments <- sapply(1:length(simMut$clones),function(i){
  sapply(1:length(resMut$filtered.data$mutdata.filt$mut.id),function(j){
    index <- which(simMut$clones[[i]]$seq$mut.id==resMut$filtered.data$mutdata.filt$mut.id[j])
    if(length(index)==0){
      val <- 0
    }else{
      val <- simMut$clones[[i]]$seq$mutated.copies[index]
    }
    val
  })
})
inferredMutAssignments <- resMut$mutated[,1:length(simMut$clones)]
colnames(inferredMutAssignments) <- colnames(trueMutAssignments) <- c('clone1','clone2','clone3')

trueMutAssignments
trueMutAssignments
@

\section{Both Sequencing and SNP Array Data}
Finally, we illustrate CloneFinder being run on a sample for which there is both SNP array and mutation data.
<<eval=FALSE, echo=TRUE>>=
#simBoth <- get(load('simBoth.rda'))$tumor
#simDatBoth <- get(load('simDatBoth.rda'))$dat
cnDat2 <- simDatBoth$cn.data
mutDat2 <- simDatBoth$seq.data
resBoth <- findClones(cndata=cnDat2, vardata=mutDat2, cnmodels=cnmodels, psis, pars=pars)
@

And we can look at the inferred allocation of tumor fraction to clones:
<<eval=TRUE, echo=TRUE>>=
resBoth$psi
simBoth$psi
@
In conclusion, CloneFinder can be applied effectively to cases where one has SNP array data, (processed) sequencing data, or both.

\end{document}