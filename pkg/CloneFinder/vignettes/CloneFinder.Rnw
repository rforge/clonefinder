%\VignetteIndexEntry{CloneFinder}
%\VignetteKeywords{SNP,Copy Number,clone,subclone}
%\VignetteDepends{stats}
%\VignettePackage{CloneFinder}
\documentclass{article}
\usepackage{Sweave}
\addtolength{\textwidth}{1in}
\addtolength{\oddsidemargin}{-.5in}
\setlength{\evensidemargin}{\oddsidemargin}
\newcommand{\code}[1]{\texttt{#1}}
\title{CloneFinder}
\author{Mark Zucker \and Kevin Coombes}
\date{November, 2018} 

\begin{document}
\SweaveOpts{concordance=TRUE}
\maketitle

\section{Introduction}
Tumors often consist of multiple distinct subpopulations or
clones. Information about the number of clones present in a tumor can
be inferred using either mutation allele frequency data, from
sequencing studies, or from copy number varants (CNVs), derived either
from sequencing or from SNP array data. The \code{CloneFinder} package
can be applied to SNP array data, sequencing data, or both, from tumor
cells from a cancer patient. \code{CloneFinder} can determine the
number of clones, the distribution of cells among clones, and the copy
number variations and mutations (depending onthe available data
sources) that occur in each clone. The presence of multiple detectable
clones is called ``clonal heterogeneity'' in the literature.

Clonal heterogeneity likely plays an important role in the clinical
course of a cancer. It is possible, for example, that the tumor cells
that will eventually become the refractory cancer after treatment are
present as a minor subclone in the tumor early on.

\section{SNP Array Data}
As usual, we start by loading the package:
<<lib>>=
library(CloneFinder)
@ 

To run \code{CloneFinder}, we will need a starting set of $\psi$
vectors as inputs, where $\psi$ records the fraction of cells
belonging to each clone. For each $\psi$ vector, the algorithm will
compute the most probable copy number state for each clone at each
segment. The maximum posterior probability is computed for each imput
psi vector, and these probabilities are used to resample new potential
psi vectors. We usually start by considering every possible
decomposition of the tumor into five clones, where the fraction
assigned to each clone is a multiple of $1/20 = 0.05$.  We can
generate this initial matrix of $\psi$ vectors as follows:
<<psis>>=
psis <- generateSimplex(20, 5)
dim(psis)
head(psis)
tail(psis)
@

For SNP array data, we also need, as input, a set of possible clonal
segment copy number states. If none exists the function will
automatically generate one. 
<<cnmodels>>=
cnmodels <- expand.grid(rep(list(0:5),5))
include <- sapply(1:nrow(cnmodels), function(i) {
  length(which(cnmodels[i,] >= 1))==5 | length(which(cnmodels[i,] <= 1)) == 5
})
cnmodels <- cnmodels[include,]
@

Now we will define the algorithm parameters:
<<pars>>=
pars <- list(sigma0 = 5,    # SNP-wise standard deviation
             ktheta = 0.3,  # geometric prior parameter on number of clones
             theta = 0.9,   # geometric prior parameter on copy number changes
             mtheta = 0.9,  # gemoetric prior parameter on point mutations
             alpha = 0.5,   # parameter for a symmetric Dirichlet prior on psi
             thresh = 0.04, # smallest possible detectble clone
             cutoff = 100,  # filter out copy number segments supported by fewer SNPs
             Q = 100,       # number of new psi vectors resamples at each iteration
             iters = 4)     # number of iterations
@

First, let's illustrate the use of CloneFinder in analyzing SNP array
data to identify the clones present. We will load in some simulated
mutation data. We'll also load in the actual simulated tumor
information so we can compare the truth with the results: 

Now we are going to simmulate copy number data for a tumor with three
clones.
<<simData>>=
set.seed(21303) # for reproducibility
simTumor <- Tumor(c(0.5, 0.3, 0.2), rounds = 100, nu = 10, pcnv = 0.8, norm.contam = FALSE)
simData <- generateTumorData(simTumor,
                             snps.seq = 10000,
                             snps.cgh = 600000,
                             mu = 70,
                             sigma.reads = 25,
                             sigma0.lrr = 0.15,
                             sigma0.baf = 0.03,
                             density.sigma = 0.1)
class(simData)
length(simData)
names(simData)
dim(simData$cn.data)
dim(simData$seq.data)
cnDat <- simData$cn.data
seqDat <- simData$seq.data
@ 

<<realWork,echo=FALSE,eval=TRUE>>=
f <- system.file("auxiliary/stash.Rda", package="CloneFinder")
if (file.exists(f)) {
  load(f)
} else {
  resCN <- findClones(cndata=cnDat, vardata=NULL, cnmodels=cnmodels, psis, pars=pars)
  resMut <- findClones(cndata=NULL, vardata=seqDat, cnmodels=cnmodels, psiset=psis, pars=pars)
  resBoth <- findClones(cndata=cnDat, vardata=somatic, cnmodels=cnmodels, psis, pars=pars)
  save(resCN, resMut, resBoth, file = "../inst/auxiliary/stash.Rda")
}
rm(f)
@ 

And the results:
<<resCN,eval=FALSE>>=
resCN <- findClones(cndata=cnDat, vardata=NULL, cnmodels=cnmodels, psis, pars=pars)
@

The results of the 'only CNV' analysis of this sample:
<<compare.psis>>=
resCN$psi
simTumor@psi
@
In this case, \code{CloneFinder} accurately estimates not only the
number of clones but also the clonal fractions. Let's look at the
clonal copy number assignments as well: 
<<CNassign>>=
trueCN_Assignments <- t(sapply(1:nrow(resCN$filtered.data$cndata.filt), function(i) {
  index <- rownames(simTumor@clones[[1]]$cn) == rownames(resCN$filtered.data$cndata.filt)[i]
  sapply(1:length(simTumor@clones),function(j){
    simTumor@clones[[j]]$cn$A[index] + simTumor@clones[[j]]$cn$B[index]
  })
}))

inferredCN_Assignments <- (resCN$A+resCN$B)[,1:length(simTumor@clones)]
colnames(inferredCN_Assignments) <- colnames(trueCN_Assignments) <- paste("clone", 1:3)

#Clonal copy numbers for each potentially 'deviant' segment, true and inferred:
trueCN_Assignments
inferredCN_Assignments
@

\section{Sequencing Data}
Now, let's illustrate the use of \code{CloneFinder} in analyzing mutation
data (by which I mean variant data such as one would find in a .vcf
file) to find clones. We will load in some simulated mutation data. We
are interested here in the variants, not the CNVs, and therefore more
specifically in somatic mutation data. The data looks like this:
<<somatic>>=
somatic <- seqDat[seqDat$status=='somatic',]
head(somatic)
@

And run clonefinder:
<<resMut, eval=FALSE>>=
resMut <- findClones(cndata=NULL, vardata=seqDat, cnmodels=cnmodels, psiset=psis, pars=pars)
@
The results show that CloneFinder reached a good approximation for 'psis', the clonal fractions:
<<resMutResults>>=
resMut$psi
simTumor@psi
@
Let's also look at the mutation assignment compared to the truth:
<<trueMut>>=
trueMutAssignments <- sapply(1:length(simTumor@clones),function(i){
  sapply(1:length(resMut$filtered.data$mutdata.filt$mut.id),function(j){
    index <- which(simTumor@clones[[i]]$seq$mut.id==resMut$filtered.data$mutdata.filt$mut.id[j])
    if(length(index)==0){
      val <- 0
    }else{
      val <- simTumor@clones[[i]]$seq$mutated.copies[index]
    }
    val
  })
})
inferredMutAssignments <- resMut$mutated[,1:length(simTumor@clones)]
colnames(inferredMutAssignments) <- colnames(trueMutAssignments) <- c('clone1','clone2','clone3')

trueMutAssignments
trueMutAssignments
@

\section{Both Sequencing and SNP Array Data}
Finally, we illustrate CloneFinder being run on a sample for which there is both SNP array and mutation data.
<<resBoth,eval=FALSE, echo=TRUE>>=
resBoth <- findClones(cndata=cnDat, vardata=somatic, cnmodels=cnmodels, psis, pars=pars)
@

And we can look at the inferred allocation of tumor fraction to clones:
<<reBothResults>>=
resBoth$psi
simTumor@psi
@
In conclusion, CloneFinder can be applied effectively to cases where one has SNP array data, (processed) sequencing data, or both.

\end{document}
